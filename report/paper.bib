@article{Min2019,
abstract = {In order to improve the efficiency of software development, developers often copy-paste code. It is found that the clone code may affect the quality of the software system, especially the maintenance and comprehension of the software, so it is necessary to find and locate it. Many clone detection techniques and tools have been proposed in the search for clone code. How to make better use of these detection techniques and tools will be very important. This paper describes the clone code and general process of clone code detection; introduces different clone code detection methods and related technologies; then conducts a summary analysis, the challenges and development direction faced by clone detection technology.},
author = {Min, Hou and Ping, Zhang Li},
doi = {10.1145/3312662.3312707},
file = {:D$\backslash$:/DocumentsOrganize//Min, Ping{\_}2019{\_}Survey on software clone detection research.pdf:pdf},
isbn = {9781450361897},
journal = {ACM International Conference Proceeding Series},
keywords = {Clone code,Clone detection,Clone management,Clone type,Software maintenance},
pages = {9--16},
title = {{Survey on software clone detection research}},
year = {2019}
}
@article{Li2017,
abstract = {Programmers produce code clones when developing software. By copying and pasting code with or without modification, developers reuse existing code to improve programming productivity. However, code clones present challenges to software maintenance: they may require consistent application of the same or similar bug fixes or program changes to multiple code locations. To simplify the maintenance process, various tools have been proposed to automatically detect clones [1], [2], [3], [4], [5], [6]. Some tools tokenize source code, and then compare the sequence or frequency of tokens to reveal clones [1], [3], [4], [5]. Some other tools detect clones using tree-matching algorithms to compare the Abstract Syntax Trees (ASTs) of source code [2], [6]. In this paper, we present CCLEARNER, the first solely token-based clone detection approach leveraging deep learning. CCLEARNER extracts tokens from known method-level code clones and non-clones to train a classifier, and then uses the classifier to detect clones in a given codebase. To evaluate CCLEARNER, we reused BigCloneBench [7], an existing large benchmark of real clones. We used part of the benchmark for training and the other part for testing, and observed that CCLEARNER effectively detected clones. With the same data set, we conducted the first systematic comparison experiment between CCLEARNER and three popular clone detection tools. Compared with the approaches not using deep learning, CCLEARNER achieved competitive clone detection effectiveness with low time cost.},
author = {Li, Liuqing and Feng, He and Zhuang, Wenjie and Meng, Na and Ryder, Barbara},
doi = {10.1109/ICSME.2017.46},
file = {:D$\backslash$:/DocumentsOrganize/Li et al.{\_}2017{\_}CCLearner A deep learning-based clone detection approach.pdf:pdf},
isbn = {9781538609927},
journal = {Proceedings - 2017 IEEE International Conference on Software Maintenance and Evolution, ICSME 2017},
keywords = {Clone detection,Deep learning,Empirical},
pages = {249--260},
title = {{CCLearner: A deep learning-based clone detection approach}},
year = {2017}
}
@article{White2016,
abstract = {Code clone detection is an important problem for software maintenance and evolution. Many approaches consider either structure or identifiers, but none of the existing detection techniques model both sources of information. These techniques also depend on generic, handcrafted features to represent code fragments. We introduce learning-based detection techniques where everything for representing terms and fragments in source code is mined from the repository. Our code analysis supports a framework, which relies on deep learning, for automatically linking patterns mined at the lexical level with patterns mined at the syntactic level. We evaluated our novel learning-based approach for code clone detection with respect to feasibility from the point of view of software maintainers. We sampled and manually evaluated 398 fileand 480 method-level pairs across eight real-world Java systems; 93{\%} of the fileand method-level samples were evaluated to be true positives. Among the true positives, we found pairs mapping to all four clone types.We compared our approach to a traditional structure-oriented technique and found that our learning-based approach detected clones that were either undetected or suboptimally reported by the prominent tool Deckard. Our results affirm that our learning-based approach is suitable for clone detection and a tenable technique for researchers.},
author = {White, Martin and Tufano, Michele and Vendome, Christopher and Poshyvanyk, Denys},
doi = {10.1145/2970276.2970326},
file = {:D$\backslash$:/DocumentsOrganize/White et al.{\_}Unknown{\_}Deep Learning Code Fragments for Code Clone Detection.pdf:pdf},
isbn = {9781450338455},
journal = {ASE 2016 - Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering},
keywords = {Abstract syntax trees,Code clone detection,Deep learning,Language models,Machine learning,Neu-ral networks},
pages = {87--98},
title = {{Deep learning code fragments for code clone detection}},
year = {2016}
}
@article{Roy2017,
author = {Roy, Chanchal K and Cordy, James R and Koschke, Rainer},
file = {:D$\backslash$:/DocumentsOrganize/Roy, Cordy, Koschke{\_}2017{\_}Comparison And Evaluation of Code Clone Detection Techniques.pdf:pdf},
issn = {2321-9653},
journal = {International Journal for Research in Applied Science and Engineering Technology},
keywords = {clone detection,comparison,scenario-based evaluation,software clone},
number = {XII},
pages = {473--476},
title = {{Comparison And Evaluation of Code Clone Detection Techniques}},
volume = {5},
year = {2017}
}
@article{Kim2011,
abstract = {In this paper, we propose a new semantic clone detection technique by comparing programs' abstract memory states, which are computed by a semantic-based static analyzer. Our experimental study using three large-scale open source projects shows that our technique can detect semantic clones that existing syntactic- or semantic-based clone detectors miss. Our technique can help developers identify inconsistent clone changes, find refactoring candidates, and understand software evolution related to semantic clones. {\textcopyright} 2011 ACM.},
author = {Kim, Heejung and Jung, Yungbum and Kim, Sunghun and Yi, Kwankeun},
doi = {10.1145/1985793.1985835},
file = {:D$\backslash$:/DocumentsOrganize/Kim et al.{\_}2011{\_}MeCC Memory comparison-based clone detector.pdf:pdf},
isbn = {9781450304450},
issn = {02705257},
journal = {Proceedings - International Conference on Software Engineering},
keywords = {abstract interpretation,clone detection,software maintenance,static analysis},
pages = {301--310},
title = {{MeCC: Memory comparison-based clone detector}},
year = {2011}
}
@article{Jiang2007,
abstract = {Detecting code clones has many software engineering applications. Existing approaches either do not scale to large code bases or are not robust against minor code modifications. In this paper, we present an efficient algorithm for identifying similar subtrees and apply it to tree representations of source code. Our algorithm is based on a novel characterization of subtrees with numerical vectors in the Euclidean space ‚Ñùn and an efficient algorithm to cluster these vectors w.r.t. the Euclidean distance metric. Subtrees with vectors in one cluster are considered similar. We have implemented our tree similarity algorithm as a clone detection tool called DECKARD and evaluated it on large code bases written in C and Java including the Linux kernel and JDK. Our experiments show that DECKARD is both scalable and accurate. It is also language independent, applicable to any language with a formally specified grammar. {\textcopyright} 2007 IEEE.},
author = {Jiang, Lingxiao and Misherghi, Ghassan and Su, Zhendong and Glondu, St{\'{e}}phane},
doi = {10.1109/ICSE.2007.30},
file = {:D$\backslash$:/DocumentsOrganize/Jiang et al.{\_}2007{\_}DECKARD Scalable and accurate tree-based detection of code clones.pdf:pdf},
isbn = {0769528287},
issn = {02705257},
journal = {Proceedings - International Conference on Software Engineering},
number = {0520320},
pages = {96--105},
title = {{DECKARD: Scalable and accurate tree-based detection of code clones}},
year = {2007}
}
@article{Yu2019,
abstract = {Code clones are similar code fragments that share the same semantics but may differ syntactically to various degrees. Detecting code clones helps reduce the cost of software maintenance and prevent faults. Various approaches of detecting code clones have been proposed over the last two decades, but few of them can detect semantic clones, i.e., code clones with dissimilar syntax. Recent research has attempted to adopt deep learning for detecting code clones, such as using tree-based LSTM over Abstract Syntax Tree (AST). However, it does not fully leverage the structural information of code fragments, thereby limiting its clone-detection capability. To fully unleash the power of deep learning for detecting code clones, we propose a new approach that uses tree-based convolution to detect semantic clones, by capturing both the structural information of a code fragment from its AST and lexical information from code tokens. Additionally, our approach addresses the limitation that source code has an unlimited vocabulary of tokens and models, and thus exploiting lexical information from code tokens is often ineffective when dealing with unseen tokens. Particularly, we propose a new embedding technique called position-aware character embedding (PACE), which essentially treats any token as a position-weighted combination of character one-hot embeddings. Our experimental results show that our approach substantially outperforms an existing state-of-the-art approach with an increase of 0.42 and 0.15 in F1-score on two popular code-clone benchmarks (OJClone and BigCloneBench), respectively, while being more computationally efficient. Our experimental results also show that PACE enables our approach to be substantially more effective when code clones contain unseen tokens.},
author = {Yu, Hao and Lam, Wing and Chen, Long and Li, Ge and Xie, Tao and Wang, Qianxiang},
doi = {10.1109/ICPC.2019.00021},
file = {:D$\backslash$:/DocumentsOrganize//Yu et al.{\_}2019{\_}Neural detection of semantic code clones via tree-based convolution.pdf:pdf},
isbn = {9781728115191},
journal = {IEEE International Conference on Program Comprehension},
keywords = {AST,Clone detection,Embedding,Generalization,Lexical information,Semantic clone,Source code,Structural information,Token,Tree-based convolution},
pages = {70--80},
title = {{Neural detection of semantic code clones via tree-based convolution}},
volume = {2019-May},
year = {2019}
}
@article{Sajnani2016,
abstract = {Despite a decade of active research, there has been a marked lack in clone detection techniques that scale to large repositories for detecting near-miss clones. In this paper, we present a token-based clone detector, SourcererCC, that can detect both exact and near-miss clones from large interproject repositories using a standard workstation. It exploits an optimized inverted-index to quickly query the potential clones of a given code block. Filtering heuristics based on token ordering are used to significantly reduce the size of the index, the number of code-block comparisons needed to detect the clones, as well as the number of required token-comparisons needed to judge a potential clone. We evaluate the scalability, execution time, recall and precision of SourcererCC, and compare it to four publicly available and state-of-the-art tools. To measure recall, we use two recent benchmarks: (1) a big benchmark of real clones, BigCloneBench, and (2) a Mutation/Injection-based framework of thousands of fine-grained artificial clones. We find SourcererCC has both high recall and precision, and is able to scale to a large inter-project repository (25K projects, 250MLOC) using a standard workstation.},
archivePrefix = {arXiv},
arxivId = {1512.06448},
author = {Sajnani, Hitesh and Saini, Vaibhav and Svajlenko, Jeffrey and Roy, Chanchal K. and Lopes, Cristina V.},
doi = {10.1145/2884781.2884877},
eprint = {1512.06448},
file = {:D$\backslash$:/DocumentsOrganize/Sajnani et al.{\_}2016{\_}SourcererCC Scaling code clone detection to big-code.pdf:pdf},
isbn = {9781450339001},
issn = {02705257},
journal = {Proceedings - International Conference on Software Engineering},
number = {1},
pages = {1157--1168},
title = {{SourcererCC: Scaling code clone detection to big-code}},
volume = {14-22-May-2016},
year = {2016}
}
